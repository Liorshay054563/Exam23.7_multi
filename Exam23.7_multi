

שאלה 1: מהו תפקיד המתודה init במחלקת פייתון

א. ליצור מופע חדש של המחלקה ולבצע בו אתחול של משתנים

----
שאלה 2: מה ההבדל המרכזי בין @staticmethod ל־@classmethod בפייתון

ב. @classmethod מקבל את המחלקה כפרמטר ראשון (cls), ו־@staticmethod לא מקבל אובייקט בכלל

-----
שאלה 3: מהי מטרת השיטה str במחלקת פייתון

ב. להחזיר ייצוג טקסטואלי של האובייקט כשמדפיסים אותו

----

שאלה 4: מה קורה כאשר מפעילים את האופרטור == על שני מופעים מאותה מחלקה בלי להגדיר את eq

ג. ההשוואה תתבצע לפי כתובת הזיכרון של המופעים

----

שאלה 5: מה נדרש כדי להפוך מחלקה לאיטרטור בפייתון

ב. לממש את המתודות iter ו-next

----

שאלה 6: מהו hash ואיזה תפקיד הוא ממלא

ב. מחזיר ערך מספרי ייחודי שמייצג את האובייקט עבור שימוש במבני נתונים כמו dict או set

-----

שאלה 7: מה מאפשרת המתודה add כאשר היא מוגדרת במחלקה

ב. שימוש באופרטור + בין מופע של המחלקה לכל אובייקט שתואם את הלוגיקה שבמתודה

----

שאלה 8: מה יקרה אם נממש eq אך לא נממש hash וננסה להשתמש במופע של המחלקה כ־key במילון (dict)

. תתקבל שגיאה מסוג TypeError

----

שאלה 9: מה היתרון המרכזי בשימוש במחלקה מופשטת (abstract base class) בפייתון

ג. היא מגדירה ממשק מחייב למחלקות שיורשות ממנה

----

שאלה 10: מה יקרה אם ננסה ליצור מופע ממחלקה שמוגדרת כ־abstract ויש בה מתודה אחת abstract שלא מומשה

ג. תתקבל שגיאה בזמן יצירת מופע

----

שאלה 11: מהי התוצאה של ניסיון לרשת ממחלקה שמסומנת כ־abstract אך לא לממש את כל המתודות ה־abstract

ב. תתקבל שגיאה בזמן יצירת מופע מהמחלקה היורשת

----

שאלה 12: מה קורה כאשר שני threads ניגשים לאותו משתנה בזיכרון בלי סנכרון מתאים

. התוצאה עלולה להיות לא צפויה בגלל מצב של race conditio

---

שאלה 13: מה ההבדל בין *args ל־**kwargs בפייתון

ג. *args אוסף ארגומנטים לפי מיקום ו־**kwargs אוסף ארגומנטים לפי מפתח
#היחידי שיכול להיות נכון
----

שאלה 14: למה משמשת המתודה hash בפייתון

א. כדי ליצור מזהה ייחודי לכל מופע לצורך השוואה

----

שאלה 15: מהי המשמעות של GIL (Global Interpreter Lock) בפייתון

ב. מגביל את פייתון כך שרק thread אחד יכול להריץ קוד פייתון בכל רגע נתון

----

שאלה 16: מה היתרון המרכזי של שימוש ב־logging על פני print בפייתון

ג. logging מאפשר רמות דיווח שונות וכתיבה לקובץ או קונסולה

---
שאלה 17: מה תהיה תוצאת הריצה של הקוד הבא
try:
    result = 10 / 0
except ValueError:
    print("Value error")
finally:
    print("Done")

ג. יודפס "Done" ואז תיזרק שגיאת ZeroDivisionError כי אין except מתאים
----
שאלה 18: הקוד הבא רץ לאט וצורך הרבה זיכרון
def process():
    data = create_big_list()
    doubled = double_values(data)
    return sum(doubled)

ג. להשתמש ב־memory_profiler עם @profile כדי למדוד שימוש בזיכרון
----

שאלה 19: מהו מצב של cycle reference בפייתון

ב. מצב שבו שני אובייקטים מחזיקים הפניה אחד לשני, כך שלא ניתן לפנות את הזיכרון

----

שאלה 20: מה תהיה תוצאת הריצה של הקוד הבא מבחינת ניהול זיכרון

ב. שני האובייקטים יישארו בזיכרון כי יש ביניהם הפניה מעגלית

----

שאלה 21: יש לך שני קבצים: module_a.py ו־module_b.py, שכל אחד מהם מייבא פונקציה מהשני

ב. לשים את ה־import בתוך הפונקציה שזקוקה לו
# באחד השיעורים האחרונים נתקלנו בדיוק במקרה הזה
-----

שאלה 22: מהי המשמעות של Reference Count בפייתון

ג. מספר הפעמים שפונקציה נקראת

-----

שאלה 23: למה משמשת Weak Reference בפייתון

ב. היא מחזיקה הפניה לאובייקט בלי למנוע מה־garbage collector למחוק אותו

----

שאלה 24: מה היתרון בהגדרת תכונה כ־private עם __name ושימוש ב־getter ו־setter עבורה

ג. מאפשר שליטה על גישה, אימות ולוגיקה לפני קריאה או שינוי של הערך

____

שאלה 25: למה נשתמש ב־multiprocessing במקום ב־threading בפייתון

ג. כי multiprocessing עוקף את מגבלת ה־GIL ולכן מתאים לעומסים חישוביים